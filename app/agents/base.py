# --- START OF FILE base.py ---

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from app.rag.rag_service import RAGService
import logging

# Setup logging
logger = logging.getLogger(__name__)


class BaseAgent(ABC):
    """Base class for all agents in the marketplace."""

    def __init__(self):
        """Initialize the base agent with RAG service access."""
        self.rag_service = RAGService.get_instance()
        self.generated_knowledge = []
        logger.info("Initializing BaseAgent")

    @abstractmethod
    def process(
        self, input_data: Dict[str, Any], context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Process the input data and return output.

        Args:
            input_data: The input data for the agent
            context: Optional workflow context data

        Returns:
            Dict containing the output data
        """
        pass

    @abstractmethod
    def get_input_schema(self) -> Dict[str, Any]:
        """Return the JSON schema for expected input."""
        pass

    @abstractmethod
    def get_output_schema(self) -> Dict[str, Any]:
        """Return the JSON schema for expected output."""
        pass

    @abstractmethod
    def get_config_schema(self) -> Dict[str, Any]:
        """Return the JSON schema for agent configuration."""
        pass

    def add_knowledge(
        self,
        collection_name: str,
        document: str,
        metadata: Optional[Dict[str, Any]] = None,
    ):
        """
        Add knowledge to a RAG collection and record it.

        Args:
            collection_name: Name of the collection to add to
            document: Text document to add
            metadata: Optional metadata for the document
        """
        self.rag_service.add_documents(
            collection_name=collection_name,
            documents=[document],
            metadatas=[metadata] if metadata else None,
        )
        self.generated_knowledge.append(
            {
                "collection": collection_name,
                "document": document,
                "metadata": metadata or {},
            }
        )
        logger.info(f"Added knowledge to collection: {collection_name}")

    def get_generated_knowledge(self) -> List[Dict[str, Any]]:
        """Get knowledge generated by this agent instance."""
        logger.info("Retrieving generated knowledge")
        return self.generated_knowledge

    def search_knowledge(
        self,
        query: str,
        collection_name: Optional[str] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> List[Dict[str, Any]]:
        """
        Search for knowledge in collections.

        Args:
            query: Text query to search for
            collection_name: Specific collection to search (if None, uses shared collections)
            context: Workflow context that may contain RAG information

        Returns:
            List of relevant documents
        """
        logger.info(
            f"Searching knowledge with query: {query}, collection: {collection_name}"
        )
        if collection_name:
            return self.rag_service.search(collection_name, query)

        # If no specific collection, check context for shared collections
        if context and "rag_context" in context:
            results = []
            shared_collections = context["rag_context"].get("shared_collections", [])

            for collection in shared_collections:
                try:
                    results.extend(self.rag_service.search(collection, query))
                except Exception as e:
                    logger.error(f"Error searching collection {collection}: {e}")
                    pass

            return results

        return []

    # Helper methods for flexible input handling

    def extract_text_content(self, input_data: Dict[str, Any]) -> str:
        """Extract text content from various input formats."""
        # Try common text content fields
        if "transcript" in input_data:
            return input_data["transcript"]
        elif "content" in input_data:
            return input_data["content"]
        elif "body" in input_data:
            return input_data["body"]
        elif "text" in input_data:
            return input_data["text"]
        elif "summary" in input_data:
            return input_data["summary"]
        # Extract from email object if present
        elif "email" in input_data and isinstance(input_data["email"], dict):
            email = input_data["email"]
            email_content = email.get("body", "")
            if "subject" in email and email["subject"]:
                email_content = f"Subject: {email['subject']}\n\n{email_content}"
            return email_content
        # Try to find the largest string field as fallback
        else:
            largest_text = ""
            for key, value in input_data.items():
                if isinstance(value, str) and len(value) > len(largest_text):
                    largest_text = value
            return largest_text

    def get_original_prompt(self, context: Optional[Dict[str, Any]]) -> str:
        """Extract the original user prompt from context."""
        if not context:
            return ""

        if "user_prompt" in context:
            return context["user_prompt"]
        elif "original_input" in context and "content" in context["original_input"]:
            return context["original_input"]["content"]

        return ""

    def extract_items_from_input(
        self, input_data: Dict[str, Any], key: str
    ) -> List[Any]:
        """Extract a list of items (like action_items) from various input formats."""
        if key in input_data:
            return input_data[key]

        # Check in nested structures
        for value in input_data.values():
            if isinstance(value, dict) and key in value:
                return value[key]

        return []

    def is_in_workflow(self, context: Optional[Dict[str, Any]] = None) -> bool:
        """
        Check if this agent is running as part of a workflow.

        Args:
            context: Optional workflow context data

        Returns:
            True if the agent is in a workflow, False otherwise
        """
        return context is not None and "workflow_id" in context

    def get_workflow_info(
        self, context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Get workflow metadata.

        Args:
            context: Optional workflow context data

        Returns:
            Dict containing workflow ID, name, or empty dict if not in a workflow
        """
        if not self.is_in_workflow(context):
            return {}

        return {
            "workflow_id": context.get("workflow_id"),
            "workflow_name": context.get("workflow_name", ""),
        }

    def get_previous_agent_results(
        self, context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Get results from all previous agents in the workflow.

        Args:
            context: Optional workflow context data

        Returns:
            Dict containing all intermediate results from previous agents
        """
        if not self.is_in_workflow(context):
            return {}

        return context.get("intermediate_results", {})

    def get_previous_agent_result(
        self, agent_order: int, context: Optional[Dict[str, Any]] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Get result from a specific previous agent in the workflow.

        Args:
            agent_order: The order number of the agent in the workflow
            context: Optional workflow context data

        Returns:
            Dict containing the specific agent's results or None if not found
        """
        results = self.get_previous_agent_results(context)
        return results.get(str(agent_order))

    def get_rag_context(
        self, context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Get RAG context from workflow context.

        Args:
            context: Optional workflow context data

        Returns:
            Dict containing RAG context data or empty dict if not available
        """
        if not context:
            return {}

        return context.get("rag_context", {})


# --- END OF FILE base.py ---
